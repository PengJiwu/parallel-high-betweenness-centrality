General Installation Guide for Extracting High Centrality Nodes in Distributed Graphs
=====================================================================================

Pre-Requisites
--------------

* We have tested our system with Linux – Ubuntu/Debian variant (although all windows equivalent s/w are available and may be used)

* MPI runtime (preferable Open MPI 1.6 or higher)

 * On a single machine

<code>sudo apt-get -y install build-essential g++ python-dev autotools-dev libicu-dev libbz2-dev</code>

<code>sudo apt-get -y install libopenmpi-dev openmpi-bin openmpi-doc</code> 
 * Set up a MPI Cluster (see http://techtinkering.com/2009/12/02/setting-up-a-beowulf-cluster-using-open-mpi-on-linux/)

* Boost Library (on each node of the cluster, run the following command)

<code>sudo apt-get -y install libboost-all-dev</code>

* Metis Graph Partitioner

<code>sudo apt-get -y install metis</code>	
 
Compile
--------

Once the prerequisite are installed, download the code from the git repository mentioned earlier.

The code is a header only library so you don’t need to compile it to use it in your application. For demonstration, a sample .cpp file is provided which uses the given API. Compile it by running make in the project directory.

Execution
---------

* First the given graph (in METIS format) needs to be portioned into desired number of partitions. For example:

<code>gpmetis ./4elt.graph 2</code>

This will create a partition file 4elt.graph.part.2

Psuedo Distributed (single node):

Use the Open MPI’s mpi-run command to start the algorithm using the desired number of processors (NOTE: This should be equal to the number of partitions)

<code>Usage: "mpirun -np 2 ./ebetwn <extract_cnt> <stable_check_cnt> <batch_size> <input_graph> <partition_file> <leaf_compress>" </code>

extract_cnt: Number of top centrality vertices to extract (typically 10-100)

stable_check_cnt: is used to determine if the set of high centrality vertices is stabilized (for the given number of iterations)

batch_size: Number of shortest paths to calculate per iteration before checking the stability of the set

input_graph: input graph in Metis format (See below for details)

partition_file: the partition file generated by the Metis partitioner

leaf_compression: 0 or 1 depending on whether a leaf compression pre processing step should be performed. This improves performance but could potentially reduce the quality of results.

Example:

<code>mpirun -np 2 ./ebetwn 10 3 5 ./4elt.graph 4elt.graph.part.2 1</code>

On MPI Cluster
--------------

Run the same command as before from the Cluster’s head node.

API
----

The code is a header only library so you don’t need to compile it to use it in your application. To construct a distributed Graph use the Boost Parallel Graph Librarie’s Adjacency List data structure. See http://www.boost.org/doc/libs/1_55_0/libs/graph_parallel/doc/html/index.html for details.

We currently provide a single public API call which takes as input the distributed graph and returns the set of high centrality vertices:

<code>void partiotined_chong_extract_high_centrality(Graph &g, CentralityMap& cm, IndexMap index_map, vertex_size_t topk, vertex_size_t bsize, vertex_size_t set_delta, vertex_size_t convergence_cnt)</code>

Further variations and convenience functions will be provided in subsequent versions.

Data Format
------------


We use the standard METIS graph data format for input graphs. See http://glaros.dtc.umn.edu/gkhome/fetch/sw/metis/manual.pdf for details.

To summarize, the metis format of the following

1. First line indicating the number of vertices and edges (and optionally the type of graph data, e.g. weighted or not)

2. All subsequent lines contain the data per vertex and its (undirected) edges in following format

optional_vertex_data e1 w1 e2 w2 …

For example: The following undirected graph is represented using:



Metis File:

4 5 001 //4: num vertices, 5: num edges, 001 -> indicates no vertex data but available edge data

2 2 3 1 4 1 // e1 w1 e2 w2 e3 w3 for vertex 1

1 2 3 2 4 1

1 3 2 2

1 4 2 1

Please see the manual for details on how to represent directed graphs.

